#!/bin/bash

# Default values
TARGET_FOLDER="."
INCLUDE_DB_DATA=false

# --- Configuration for ignores ---
IGNORE_TREE_PATTERNS=".env|__pycache__|.git|.vs|Debug|Release|build|target|.next|dist|out|node_modules|.idea|.vscode|Cargo.lock|package-lock.json|pnpm-lock.yaml|go.sum|*_report.txt"
IGNORE_FIND_FILES=".env, *_report.txt"
IGNORE_FIND_DIRS="__pycache__, .git, .vs, Debug, Release, build"
# ---------------------------------

# --- Parse Arguments ---
for arg in "$@";
do
  if [[ "$arg" == "--data" ]]; then
    INCLUDE_DB_DATA=true
  elif [[ "$arg" == -* ]];
  then
    echo "Unknown option: $arg"
    exit 1
  else
    TARGET_FOLDER="$arg"
  fi
done

# Check if the target folder actually exists
if [ ! -d "$TARGET_FOLDER" ]; then
  echo "Error: Folder '$TARGET_FOLDER' does not exist."
  exit 1
fi

# Get the base name (using realpath to avoid hidden files)
FOLDER_NAME=$(basename "$(realpath "$TARGET_FOLDER")")
OUTPUT_FILE="${FOLDER_NAME}_report.txt"

# --- Start the report ---
echo "Generating report for: $TARGET_FOLDER"
if [ "$INCLUDE_DB_DATA" = true ];
then
    echo "Mode: Including FULL Database Data (Rows)"
else
    echo "Mode: Schema Only (Structure)"
fi
echo "Saving to: $OUTPUT_FILE"

# Step 1: Tree Structure
echo "=== FOLDER TREE FOR: $TARGET_FOLDER ===" > "$OUTPUT_FILE"
tree -a "$TARGET_FOLDER" -I "$IGNORE_TREE_PATTERNS" >> "$OUTPUT_FILE"
echo -e "\n\n=======================\n\n" >> "$OUTPUT_FILE"

# Step 2: File Contents
echo "=== FILE CONTENTS ===" >> "$OUTPUT_FILE"

# Find files, sort them, and loop through
find "$TARGET_FOLDER" \
  \( -type d -name ".git" -prune \) -o \
  \( -type d -name "__pycache__" -prune \) -o \
  \( -type d -name ".vs" -prune \) -o \
  \( -type d -name "Debug" -prune \) -o \
  \( -type d -name "Release" -prune \) -o \
  \( -type d -name "build" -prune \) -o \
  \( -type d -name "target" -prune \) -o \
  \( -type d -name "node_modules" -prune \) -o \
  \( -type d -name ".next" -prune \) -o \
  \( -type d -name "dist" -prune \) -o \
  \( -type d -name "out" -prune \) -o \
  \( -type d -name ".idea" -prune \) -o \
  \( -type d -name ".vscode" -prune \) -o \
  \( -type f -name "Cargo.lock" -prune \) -o \
  \( -type f -name "package-lock.json" -prune \) -o \
  \( -type f -name "pnpm-lock.yaml" -prune \) -o \
  \( -type f -name "go.sum" -prune \) -o \
  \( -type f -name ".env" -prune \) -o \
  \( -type f -name "*_report.txt" -prune \) -o \
  \( -type f -print \) | sort | while read file;
do

  echo -e "\n\n--- Content of: $file ---" >> "$OUTPUT_FILE"

  # 1. Handle PDF Files
  if [[ "$file" == *.pdf ]];
  then
    if pdftotext "$file" - >> "$OUTPUT_FILE" 2>/dev/null;
    then
      : # Success
    else
      echo "[Could not extract text from PDF]" >> "$OUTPUT_FILE"
    fi

  # 2. Handle SQLite Database Files
  elif [[ "$file" == *.db || "$file" == *.sqlite || "$file" == *.sqlite3 ]]; then
    if command -v sqlite3 &> /dev/null;
    then
      if [ "$INCLUDE_DB_DATA" = true ];
      then
         echo ">>> Extracting FULL SQLite Schema AND Data..." >> "$OUTPUT_FILE"
         if sqlite3 "$file" .dump >> "$OUTPUT_FILE" 2>/dev/null;
         then :; else
            echo "[Error reading SQLite file]" >> "$OUTPUT_FILE"
         fi
      else
         echo ">>> Extracting SQLite Schema Only (Use --data to see rows)..." >> "$OUTPUT_FILE"
         if sqlite3 "$file" .schema >> "$OUTPUT_FILE" 2>/dev/null;
         then :; else
            echo "[Error reading SQLite file]" >> "$OUTPUT_FILE"
         fi
      fi
    else
      echo "[Binary SQLite file detected. Install 'sqlite3' to see text dump]" >> "$OUTPUT_FILE"
    fi

  # 3. [NEW] Handle Images, Videos, Pickles, and Build/Binary Files
  # Skips content dumping for these extensions
  elif [[ "$file" =~ \.(pkl|jpg|jpeg|png|gif|bmp|svg|webp|ico|mp4|mkv|avi|mov|wmv|flv|webm|ttf|otf|woff|woff2|eot|mp3|wav|zip|tar|gz|rar|exe|dll|so|obj|o|out|bin|pdb|class|tlog|ilk|idb|ipch|pch|gch|xlsx|xls|doc|docx|ppt|pptx|jar)$ ]]; then
    echo "[Skipping binary or build log file]" >> "$OUTPUT_FILE"
    
  # 4. Handle Regular Files (Default)
  else
    if cat "$file" >> "$OUTPUT_FILE" 2>/dev/null;
    then
      : # Success
    else
      echo "[Content is binary or unreadable]" >> "$OUTPUT_FILE"
    fi
  fi

  echo -e "--- End of: $file ---" >> "$OUTPUT_FILE"
done

echo "Done! Report saved to $OUTPUT_FILE"
